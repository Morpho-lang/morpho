/** @file clss.c
 *  @author T J Atherton
 *
 *  @brief Defines class object type
 */

#include "morpho.h"
#include "classes.h"

/* **********************************************************************
 * objectclass definitions
 * ********************************************************************** */

/** Class object definitions */
void objectclass_printfn(object *obj, void *v) {
    morpho_printf(v, "@%s", MORPHO_GETCSTRING(((objectclass *) obj)->name));
}

void objectclass_markfn(object *obj, void *v) {
    objectclass *c = (objectclass *) obj;
    morpho_markvalue(v, c->name);
    morpho_markdictionary(v, &c->methods);
    morpho_markvarrayvalue(v, &c->parents);
    morpho_markvarrayvalue(v, &c->children);
}

void objectclass_freefn(object *obj) {
    objectclass *klass = (objectclass *) obj;
    morpho_freeobject(klass->name);
    dictionary_clear(&klass->methods);
    varray_valueclear(&klass->parents);
    varray_valueclear(&klass->children);
    varray_valueclear(&klass->linearization);
}

size_t objectclass_sizefn(object *obj) {
    return sizeof(objectclass);
}

objecttypedefn objectclassdefn = {
    .printfn=objectclass_printfn,
    .markfn=objectclass_markfn,
    .freefn=objectclass_freefn,
    .sizefn=objectclass_sizefn,
    .hashfn=NULL,
    .cmpfn=NULL
};

objectclass *object_newclass(value name) {
    objectclass *newclass = (objectclass *) object_new(sizeof(objectclass), OBJECT_CLASS);

    if (newclass) {
        newclass->name=object_clonestring(name);
        dictionary_init(&newclass->methods);
        varray_valueinit(&newclass->parents);
        varray_valueinit(&newclass->children);
        newclass->superclass=NULL;
        newclass->uid=0;
    }

    return newclass;
}

/* **********************************************************************
 * objectclass utility functions
 * ********************************************************************** */

bool _merge(varray_value *klasses, varray_value *out) {
    
}

bool _linearize(objectclass *klass, varray_value *out) {
    varray_valuewrite(out, MORPHO_OBJECT(out));
    _merge(&klass->parents, out);
}

/** Computes the linearization of a class */
bool class_linearize(objectclass *klass) {
    klass->linearization.count=0;
    
    return _linearize(klass, &klass->linearization);
}

/* **********************************************************************
 * (Future) Class veneer class
 * ********************************************************************** */

value Class_linearize(vm *v, int nargs, value *args) {
    objectclass *klass=MORPHO_GETCLASS(MORPHO_SELF(args));
    value out = MORPHO_NIL;
    
    
    
    return out;
}

MORPHO_BEGINCLASS(Class)
MORPHO_METHOD(MORPHO_TOSTRING_METHOD, Class_linearize, BUILTIN_FLAGSEMPTY)
MORPHO_ENDCLASS

/* **********************************************************************
 * Initialization and finalization
 * ********************************************************************** */

objecttype objectclasstype;

void class_initialize(void) {
    // objectclass is a core type so is intialized earlier
    
    // Locate the Object class to use as the parent class of Class
    objectstring objname = MORPHO_STATICSTRING(OBJECT_CLASSNAME);
    value objclass = builtin_findclass(MORPHO_OBJECT(&objname));
    
    value classclass=builtin_addclass(CLASS_CLASSNAME, MORPHO_GETCLASSDEFINITION(Class), objclass);
    object_setveneerclass(OBJECT_CLASS, classclass);
    
    // No constructor function; classes are generated by the compiler
    
    // Class error messages
    morpho_defineerror(CLASS_INVK, ERROR_HALT, CLASS_INVK_MSG);
}
